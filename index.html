<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Jcoz by Decave</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/Decave/JCoz">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/Decave/JCoz/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/Decave/JCoz/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Jcoz</h1>
          <p>Java Causal Profiler</p>
          <p>&copy; Copyright 2016 Matthew Perron (mperron) and David Vernet (dcv)</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/Decave">David Vernet</a> and <a href="https://github.com/MattPerron">Matt Perron</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

<h2>Checkpoint</h2>
    <h3>Schedule</h3>
          <p>See schedule at bottom of page for most up-to-date schedule</p>

    <h3>Work completed</h3>
        <p>We have completed almost all of the goals listed in the first 3 weeks of our schedule; that is, getting oriented with the JVMTI and JNI interfaces, 
          adding hooks and event handlers for all of the profiling events we need, adding data structures for maintaining all profiling metrics, 
          adding virtual speedup logic, and calculating and displaying profile output / speedup information. However, we currently only support end-to-end profiling
          (as opposed to throughput profiling). In addition, the JVMTI does not always provide sufficiently granular results when being queried for threads' stack
          traces. We have a potential solution in mind to solve this that we are currently working on, but if this is not successful we will just use the
          normal JVMTI stack tracing interface and instead calculate speedups based on function calls rather than lines.
        </p>

        <p>
           We are on-schedule in terms of our goals and deliverables. If we continue to make progress at the current rate, we expect to be able to complete
           JCoz according to the original schedule, as well as utilize it in profiling major java libraries. Though we do not yet have profiler results, we
           intend to profile major java libraries, hopefully optimize them, and show these results in our presentation for the parallel competition.
        </p>

    <h3>Concerns</h3>
        <p>
            We have two concerning issues. As mentioned above, we are concerned that the JVMTI does not provide an interface for getting sufficiently granular
            stack trace results during profiling. In addition, we are worried that our profiler will have too much overhead, which can render a causal profiler 
            to be rather ineffective. We are keeping this in mind in our implementation, and are employing optimizations mentioned in the paper
            (such as sampling and minimal synchronization) to keep the profiler's overhead as low as possible. Unfortunately, until we complete the profiler and
            use it to profile libraries, we won't know if our profiler is sufficiently lightweight to be effective.
        </p>

<h2>Original Writeup</h2>

<!-- Summary -->
<h3><a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Project Summary</h3>
<p>
   We are going to implement a causal profiler for parallel Java programs.
   We will test the profiler on a few widely used libraries and attempt to optimize those libraries with our results.
</p>

<!-- Background -->
<h3><a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Background</h3>
<p>
    We are going to implement a Java version of the <a href="https://github.com/plasma-umass/coz" target="_blank">Coz profiler</a> that was presented at SOSP 2015
    and awarded best paper. The profiler works by randomly selecting lines in a program, freezing all other threads for a randomly
    chosen period of time while the current threads run, and measuring the virtual speedup of the program relative to <i>progress points</i> chosen by the programmer,
    or end to end runtime of the program. We have chosen to implement the project for Java because it has already been written for C/C++ by the authors of the original
    paper linked above. In addition, a huge portion of the business software market is written in Java, and this could potentially be a valuable tool with deep market
    reach if successful.
</p>

<p>
    We feel that this new approach to profiling is very vauable for measuring parallel programs. Current profilers simply measure the time spent in a given function,
    and the number of times that function is called. This fails to measure subtleties of how optimizations can imporve or harm parallel program runtimes. Take the following
    example (taken from <a href="https://github.com/plasma-umass/coz/raw/master/Coz-Curtsinger-Berger-SOSP2015.pdf" target="_blank">https://github.com/plasma-umass/coz/raw/master/Coz-Curtsinger-Berger-SOSP2015.pdf</a>):
    <tt>
        <br />void a() {<br />
        &emsp;for(volatile size_t x = 0; x < 20000000000; x++) {} <br />
        }<br />
        void b() {<br />
        &emsp;for(volatile size_t x = 0; x < 19000000000; x++) {}<br />
        }<br />
        <br />
        int main() {<br />
        &emsp;thread thread_a(a), thread_b(b);<br />
        &emsp;thread_a.join(); thread_b.join();<br />
        }<br />
    </tt><br />

    A normal profiler such as <tt>gprof</tt> might indicate that we spent 55% of the time in <tt>a()</tt>, and 45% of the runtime in <tt>b()</tt>. However,
    we know that speeding up <tt>b()</tt> would result in no speedup on a 2+ core machine. A causal profiler would reveal this, because a virtual speedup of <tt>b()</tt>
    wouldn't result in an overall speedup of the program. In addition, the ease of understanding the output of a causal profiler is valuable.
    While some profilers (i.e. <tt>perf</tt> showing how many cache misses occur) would attempt to indicate how to fix a problem,
    a causal profiler simply tells you where you should focus your development effort to achieve maximum speedup.
</p>

<!-- The Challenge -->
<h3><a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Challenge</h3>
<p>
    Though the causal approach to profiling is elegant and surprisingly simple, we will be interacting with the JVM at a level that requires understanding of how the
    JVM works, how to freeze and resume threads, and how to map progress points to source code. In addition, though at a high level causal profiling is rather simple,
    there are technical subtleties that will require substantial planning and careful design. For example, it is important to choose source lines to virtually
    speed-up uniformly at random to avoid introducing bias into the profiler. Also, I/O introduces quite a bit of complexity, as we still want to have threads that
    are waiting on I/O be frozen when they return from that I/O to achieve accurate virtual speedup. This will likely be a stretch goal, but subtleties such as these
    occur quite frequently in causal profiling and it may prove challenging to design a profiler that addresses them well.
</p>

<!-- Resources -->
<h3><a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Resources</h3>
<p>
    We will perform development on a Unix system in C++. Java provides a robust API for interacting with the JVM (the Java Virtual Machine Tool Interface), which we
    will utilize heavily in our development. Though our codebase will be starting from scratch, the design of our project will follow from the codebase written
    by the paper authors for C/C++. In addition, we will be implementing the profiler described in the paper, so it will be a guide when designing and building
    our project.
</p>
<p>
    We have considered testing our profiler on a variety of different machines when we attempt to optimize well known Java libraries, so having access to latedays,
    or other high performance / multicore / multi-CPU / etc machines may prove useful during this testing phase.
</p>

<!-- Goals and Deliverables -->
<h3><a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals and Deliverables</h3>

<p>
    <h4>Plan to Achieve</h4>
    <ol>
        <li>A working causal profiler with end to end latency metrics (without handling disc or network I/O)</li>
        <li>Add ability to mark progress points for measuring program throughput with finer granularity</li>
        <li>Profile some well known Java libraries (tbd)</li>
    </ol>
    We believe that we can achieve the above goals because the above features have been implemented in the original version of Coz in C++, so we believe that
    it should be possible to implement them for Java as well. In addition, we have done some exploration of the JVMTI API, and we believe that it is should provide
    the interface necessary to implement our profiler.

    <h4>Hope to Achieve</h4>
    <ol>
        <li>After profiling Java libraries, optimize those libraries and demonstrate results</li>
        <li>Add latency measurement feature</li>
        <li>Add I/O handling</li>
    </ol>
    Here are some Java libraries, some of which we are considering optimizing:
    <ul>
        <li><a href="http://tomcat.apache.org/" target="_blank">Tomcat</a></li>
        <li><a href="http://math.nist.gov/javanumerics/jama/" target="_blank">JAMA (a Java Matrix package)</a></li>
        <li><a href="http://www.ehcache.org/" target="_blank">Java EHCache</a></li>
        <li><a href="http://www.h2database.com/html/main.html" target="_blank">Java H2 Database</a></li>
        <li><a href="https://projects.apache.org/project.html?activemq" target="_blank">Apache ActiveMQ</a></li>
        <li><a href="https://github.com/apache/hive" target="_blank">Apache Hive</a></li>
        <li><a href="https://projects.apache.org/project.html?kafka" target="_blank">Apache Kafka (not Java but runs on JVM)</a></li>
        <li><a href="https://lucene.apache.org/" target="_blank">Apache Lucene</a></li>
        <li><a href="https://projects.apache.org/project.html?giraph" target="_blank">Apache Giraph</a></li>
        <li><a href="https://projects.apache.org/project.html?hbase" target="_blank">Apache HBase</a></li>
        <li><a href="http://hsqldb.org/" target="_blank">Hyper SQL Database</a></li>
    </ul>
    And here is a link to <a href="https://projects.apache.org/projects.html?language" target="_blank">more Apache projects</a>
    <br /><br />

    <h4>Parallelism Competition</h4>
    We will demonstrate the results of running our profiler on toy problems to indicate the basic features of the profiler.
    If we are able to optimize well known Java libraries, we will explain our optimizations, 
    how JCoz helped us to locate those optimizations, and illustrate the differences in runtime.
</p>

<!-- Platform choice -->
<h3><a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Platform Choice</h3>
<p>
    Multicore Unix systems are an appropriate platform for this project. We hope to test our code on a variety of hardware platforms, including
    personal computers and high performance machines. It makes sense to test using a variety of systems to validate our project idea.
</p>

<!-- Schedule -->
<h3><a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Schedule</h3>
<p>
    <ul>
        <li>4/03 - 4/09 -- Get oriented with JVMTI and intercept all events we need to intercept (i.e. breakpoints, load classes, etc)</li>
        <li>4/10 - 4/16 -- Add data structures for maintaining profiling information and add virtual speedup logic</li>
        <li>4/17 - 4/23 -- Calculate speedup information and output profile information from data structures (output a profile)</li>
        <li>4/24 - 4/30 -- Profile toy examples and profile more mature parallel Java libraries</li>
        <li>5/01 - 5/09 -- Attempt to optimize Java libraries and create final presentation</li>
    </ul>
</p>

</section>

</div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
